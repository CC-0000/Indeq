name: Deploy to Amazon EC2

on:
  push:
    branches:
      - cicd  # Trigger deployment on the cicd branch

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY_NAMESPACE: indeq
  IMAGE_TAG: ${{ github.run_id }}

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write  # For OIDC auth (recommended)
      contents: read

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v2

    - name: Install Protocol Buffers Compiler
      run: |
        sudo apt-get update
        sudo apt-get install -y protobuf-compiler

    - name: Install Go
      run: |
        sudo apt-get update
        sudo apt-get install -y golang-go

    - name: Install protoc-gen-go
      run: |
        go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
        echo "GOPATH=$(go env GOPATH)" >> $GITHUB_ENV
        echo "PATH=$PATH:$(go env GOPATH)/bin" >> $GITHUB_ENV

    - name: Install protoc-gen-go-grpc
      run: |
        go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
        echo "GOPATH=$(go env GOPATH)" >> $GITHUB_ENV
        echo "PATH=$PATH:$(go env GOPATH)/bin" >> $GITHUB_ENV

    - name: Check protoc-gen-go Installation
      run: |
        protoc-gen-go --version || echo "protoc-gen-go not found"

    - name: Generate .env Files
      env:
        DEV_PROD: ${{ secrets.DEV_PROD }}
        AUTH_PORT: ${{ secrets.AUTH_PORT }}
        AUTH_ADDRESS: ${{ secrets.AUTH_ADDRESS }}
        QUERY_PORT: ${{ secrets.QUERY_PORT }}
        QUERY_ADDRESS: ${{ secrets.QUERY_ADDRESS }}
        VECTOR_PORT: ${{ secrets.VECTOR_PORT }}
        VECTOR_ADDRESS: ${{ secrets.VECTOR_ADDRESS }}
        DESKTOP_ADDRESS: ${{ secrets.DESKTOP_ADDRESS }}
        DESKTOP_PORT: ${{ secrets.DESKTOP_PORT }}
        DESKTOP_HTTP_PORT: ${{ secrets.DESKTOP_HTTP_PORT }}
        DESKTOP_HTTP_ADDRESS: ${{ secrets.DESKTOP_HTTP_ADDRESS }}
        GATEWAY_ADDRESS: ${{ secrets.GATEWAY_ADDRESS }}
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
        POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        POSTGRES_DB: ${{ secrets.POSTGRES_DB }}
        JWT_SECRET: ${{ secrets.JWT_SECRET }}
        ARGON2_MEMORY: ${{ secrets.ARGON2_MEMORY }}
        ARGON2_ITERATIONS: ${{ secrets.ARGON2_ITERATIONS }}
        ARGON2_PARALLELISM: ${{ secrets.ARGON2_PARALLELISM }}
        ARGON2_SALT_LENGTH: ${{ secrets.ARGON2_SALT_LENGTH }}
        ARGON2_KEY_LENGTH: ${{ secrets.ARGON2_KEY_LENGTH }}
        MIN_PASSWORD_LENGTH: ${{ secrets.MIN_PASSWORD_LENGTH }}
        MAX_PASSWORD_LENGTH: ${{ secrets.MAX_PASSWORD_LENGTH }}
        MAX_EMAIL_LENGTH: ${{ secrets.MAX_EMAIL_LENGTH }}
        RABBITMQ_URL: ${{ secrets.RABBITMQ_URL }}
        RABBITMQ_DEFAULT_USER: ${{ secrets.RABBITMQ_DEFAULT_USER }}
        RABBITMQ_DEFAULT_PASS: ${{ secrets.RABBITMQ_DEFAULT_PASS }}
        RABBITMQ_LOGS: ${{ secrets.RABBITMQ_LOGS }}
        KAFKA_BROKER_ADDRESS: ${{ secrets.KAFKA_BROKER_ADDRESS }}
        KAFKA_BROKER_ID: ${{ secrets.KAFKA_BROKER_ID }}
        KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: ${{ secrets.KAFKA_LISTENER_SECURITY_PROTOCOL_MAP }}
        KAFKA_ADVERTISED_LISTENERS: ${{ secrets.KAFKA_ADVERTISED_LISTENERS }}
        KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: ${{ secrets.KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR }}
        KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: ${{ secrets.KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS }}
        KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: ${{ secrets.KAFKA_TRANSACTION_STATE_LOG_MIN_ISR }}
        KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: ${{ secrets.KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR }}
        KAFKA_PROCESS_ROLES: ${{ secrets.KAFKA_PROCESS_ROLES }}
        KAFKA_NODE_ID: ${{ secrets.KAFKA_NODE_ID }}
        KAFKA_CONTROLLER_QUORUM_VOTERS: ${{ secrets.KAFKA_CONTROLLER_QUORUM_VOTERS }}
        KAFKA_LISTENERS: ${{ secrets.KAFKA_LISTENERS }}
        KAFKA_INTER_BROKER_LISTENER_NAME: ${{ secrets.KAFKA_INTER_BROKER_LISTENER_NAME }}
        KAFKA_CONTROLLER_LISTENER_NAMES: ${{ secrets.KAFKA_CONTROLLER_LISTENER_NAMES }}
        CLUSTER_ID: ${{ secrets.CLUSTER_ID }}
        KAFKA_LOG4J_ROOT_LOGLEVEL: ${{ secrets.KAFKA_LOG4J_ROOT_LOGLEVEL }}
        KAFKA_LOG4J_LOGGERS: ${{ secrets.KAFKA_LOG4J_LOGGERS }}
        OLLAMA_URL: ${{ secrets.OLLAMA_URL }}
        LLM_MODEL: ${{ secrets.LLM_MODEL }}
        EMBED_URL: ${{ secrets.EMBED_URL }}
        EMBED_MODEL: ${{ secrets.EMBED_MODEL }}
        ZILLIZ_ADDRESS: ${{ secrets.ZILLIZ_ADDRESS }}
        ZILLIZ_API_KEY: ${{ secrets.ZILLIZ_API_KEY }}
        VECTOR_DIMENSION: ${{ secrets.VECTOR_DIMENSION }}
        CA_CRT: ${{ secrets.CA_CRT }}
        QUERY_CRT: ${{ secrets.QUERY_CRT }}
        QUERY_KEY: ${{ secrets.QUERY_KEY }}
        AUTH_CRT: ${{ secrets.AUTH_CRT }}
        AUTH_KEY: ${{ secrets.AUTH_KEY }}
        VECTOR_CRT: ${{ secrets.VECTOR_CRT }}
        VECTOR_KEY: ${{ secrets.VECTOR_KEY }}
        GATEWAY_CRT: ${{ secrets.GATEWAY_CRT }}
        GATEWAY_KEY: ${{ secrets.GATEWAY_KEY }}
        DESKTOP_CRT: ${{ secrets.DESKTOP_CRT }}
        DESKTOP_KEY: ${{ secrets.DESKTOP_KEY }}
        ALLOWED_CLIENT_IP: ${{ secrets.ALLOWED_CLIENT_IP }}
        EC2_KEY_PAIR: ${{ secrets.EC2_KEY_PAIR }}
        EC2_PUBLIC_IP: ${{ secrets.EC2_PUBLIC_IP }}
        EC2_PUBLIC_HOST: ${{ secrets.EC2_PUBLIC_HOST }}
        ROOT_CA_CERT: ${{ secrets.ROOT_CA_CERT }}
      run: |
        echo "DEV_PROD=$DEV_PROD" > .env
        echo "AUTH_PORT=$AUTH_PORT" >> .env
        echo "AUTH_ADDRESS=$AUTH_ADDRESS" >> .env
        echo "QUERY_PORT=$QUERY_PORT" >> .env
        echo "QUERY_ADDRESS=$QUERY_ADDRESS" >> .env
        echo "VECTOR_PORT=$VECTOR_PORT" >> .env
        echo "VECTOR_ADDRESS=$VECTOR_ADDRESS" >> .env
        echo "DESKTOP_ADDRESS=$DESKTOP_ADDRESS" >> .env
        echo "DESKTOP_PORT=$DESKTOP_PORT" >> .env
        echo "DESKTOP_HTTP_PORT=$DESKTOP_HTTP_PORT" >> .env
        echo "DESKTOP_HTTP_ADDRESS=$DESKTOP_HTTP_ADDRESS" >> .env
        echo "GATEWAY_ADDRESS=$GATEWAY_ADDRESS" >> .env
        echo "DATABASE_URL=$DATABASE_URL" >> .env
        echo "POSTGRES_USER=$POSTGRES_USER" >> .env
        echo "POSTGRES_PASSWORD=$POSTGRES_PASSWORD" >> .env
        echo "POSTGRES_DB=$POSTGRES_DB" >> .env
        echo "JWT_SECRET=$JWT_SECRET" >> .env
        echo "ARGON2_MEMORY=$ARGON2_MEMORY" >> .env
        echo "ARGON2_ITERATIONS=$ARGON2_ITERATIONS" >> .env
        echo "ARGON2_PARALLELISM=$ARGON2_PARALLELISM" >> .env
        echo "ARGON2_SALT_LENGTH=$ARGON2_SALT_LENGTH" >> .env
        echo "ARGON2_KEY_LENGTH=$ARGON2_KEY_LENGTH" >> .env
        echo "MIN_PASSWORD_LENGTH=$MIN_PASSWORD_LENGTH" >> .env
        echo "MAX_PASSWORD_LENGTH=$MAX_PASSWORD_LENGTH" >> .env
        echo "MAX_EMAIL_LENGTH=$MAX_EMAIL_LENGTH" >> .env
        echo "RABBITMQ_URL=$RABBITMQ_URL" >> .env
        echo "RABBITMQ_DEFAULT_USER=$RABBITMQ_DEFAULT_USER" >> .env
        echo "RABBITMQ_DEFAULT_PASS=$RABBITMQ_DEFAULT_PASS" >> .env
        echo "RABBITMQ_LOGS=$RABBITMQ_LOGS" >> .env
        echo "KAFKA_BROKER_ADDRESS=$KAFKA_BROKER_ADDRESS" >> .env
        echo "KAFKA_BROKER_ID=$KAFKA_BROKER_ID" >> .env
        echo "KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=$KAFKA_LISTENER_SECURITY_PROTOCOL_MAP" >> .env
        echo "KAFKA_ADVERTISED_LISTENERS=$KAFKA_ADVERTISED_LISTENERS" >> .env
        echo "KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=$KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR" >> .env
        echo "KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS=$KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS" >> .env
        echo "KAFKA_TRANSACTION_STATE_LOG_MIN_ISR=$KAFKA_TRANSACTION_STATE_LOG_MIN_ISR" >> .env
        echo "KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=$KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR" >> .env
        echo "KAFKA_PROCESS_ROLES=$KAFKA_PROCESS_ROLES" >> .env
        echo "KAFKA_NODE_ID=$KAFKA_NODE_ID" >> .env
        echo "KAFKA_CONTROLLER_QUORUM_VOTERS=$KAFKA_CONTROLLER_QUORUM_VOTERS" >> .env
        echo "KAFKA_LISTENERS=$KAFKA_LISTENERS" >> .env
        echo "KAFKA_INTER_BROKER_LISTENER_NAME=$KAFKA_INTER_BROKER_LISTENER_NAME" >> .env
        echo "KAFKA_CONTROLLER_LISTENER_NAMES=$KAFKA_CONTROLLER_LISTENER_NAMES" >> .env
        echo "CLUSTER_ID=$CLUSTER_ID" >> .env
        echo "KAFKA_LOG4J_ROOT_LOGLEVEL=$KAFKA_LOG4J_ROOT_LOGLEVEL" >> .env
        echo "KAFKA_LOG4J_LOGGERS=$KAFKA_LOG4J_LOGGERS" >> .env
        echo "OLLAMA_URL=$OLLAMA_URL" >> .env
        echo "LLM_MODEL=$LLM_MODEL" >> .env
        echo "EMBED_URL=$EMBED_URL" >> .env
        echo "EMBED_MODEL=$EMBED_MODEL" >> .env
        echo "ZILLIZ_ADDRESS=$ZILLIZ_ADDRESS" >> .env
        echo "ZILLIZ_API_KEY=$ZILLIZ_API_KEY" >> .env
        echo "VECTOR_DIMENSION=$VECTOR_DIMENSION" >> .env
        echo "CA_CRT=$CA_CRT" >> .env
        echo "QUERY_CRT=$QUERY_CRT" >> .env
        echo "QUERY_KEY=$QUERY_KEY" >> .env
        echo "AUTH_CRT=$AUTH_CRT" >> .env
        echo "AUTH_KEY=$AUTH_KEY" >> .env
        echo "VECTOR_CRT=$VECTOR_CRT" >> .env
        echo "VECTOR_KEY=$VECTOR_KEY" >> .env
        echo "GATEWAY_CRT=$GATEWAY_CRT" >> .env
        echo "GATEWAY_KEY=$GATEWAY_KEY" >> .env
        echo "DESKTOP_CRT=$DESKTOP_CRT" >> .env
        echo "DESKTOP_KEY=$DESKTOP_KEY" >> .env
        echo "ALLOWED_CLIENT_IP=$ALLOWED_CLIENT_IP" >> .env
        echo "EC2_KEY_PAIR=$EC2_KEY_PAIR" >> .env
        echo "EC2_PUBLIC_IP=$EC2_PUBLIC_IP" >> .env
        echo "EC2_PUBLIC_HOST=$EC2_PUBLIC_HOST" >> .env
        echo "ROOT_CA_CERT=$ROOT_CA_CERT" >> .env
        mv .env backend/common/config/.env

    - name: Generate Code
      run: |
        cd backend/common && make gen

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v1

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      run: |
        aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com

    - name: Build and Push Docker Images
      run: |
        docker build -t authentication:$IMAGE_TAG -f backend/authentication/Dockerfile backend
        authImage = ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY_NAMESPACE/authentication:$IMAGE_TAG
        docker tag authentication:$IMAGE_TAG $authImage
        docker push $authImage

        docker build -t query:$IMAGE_TAG -f backend/query/Dockerfile backend
        queryImage = ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY_NAMESPACE/query:$IMAGE_TAG
        docker tag query:$IMAGE_TAG $queryImage
        docker push $queryImage

        docker build -t gateway:$IMAGE_TAG -f backend/gateway/Dockerfile backend
        gatewayImage = ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.$AWS_REGION.amazonaws.com/$ECR_REPOSITORY_NAMESPACE/gateway:$IMAGE_TAG
        docker tag gateway:$IMAGE_TAG $gatewayImage
        docker push $gatewayImage

        # Replace placeholder image references with actual ECR URLs
        sed -i "s|authImage|$authImage|g" backend/docker-compose-ec2.yaml
        sed -i "s|queryImage|$queryImage|g" backend/docker-compose-ec2.yaml
        sed -i "s|gatewayImage|$gatewayImage|g" backend/docker-compose-ec2.yaml

    - name: Extract EC2 Key Pair
      run: |
        # Extract markers
        BEGIN_MARKER="-----BEGIN RSA PRIVATE KEY-----"
        END_MARKER="-----END RSA PRIVATE KEY-----"
        
        # Create PEM file with proper formatting
        echo "$BEGIN_MARKER" > private_key.pem
        echo "${{ secrets.EC2_KEY_PAIR }}" | sed 's/.\{64\}/&\n/g' >> private_key.pem
        echo "$END_MARKER" >> private_key.pem

        chmod 600 private_key.pem

    - name: Predeploy Cleanup
      run: |
        # SSH into EC2 to create directories first for clean up
        ssh -vvv -o StrictHostKeyChecking=no -i private_key.pem ec2-user@${{ secrets.EC2_PUBLIC_IP }} << 'EOF'

          # Print current directory and list contents
          pwd
          ls -la
          ls -la backend/
          cat backend/docker-compose-ec2.yaml

          # Create necessary directories if they don't exist
          if [ ! -d "/home/ec2-user/common/config" ]; then
            mkdir -p /home/ec2-user/common/config
          fi

          # If directory exists, remove .env inside
          if [ -f "/home/ec2-user/common/config/.env" ]; then
            rm /home/ec2-user/common/config/.env
          fi

          # Stop and remove containers safely
          if [ "$(docker ps -q)" ]; then
            docker stop $(docker ps -q)
          fi
          if [ "$(docker ps -aq)" ]; then
            docker rm $(docker ps -aq)
          fi

          docker image prune -a
          docker network prune -a
        EOF

    - name: Copy docker-compose file to EC2
      run: |
        # Copy the docker-compose file to EC2
        scp -o StrictHostKeyChecking=no -i private_key.pem backend/docker-compose-ec2.yaml ec2-user@${{ secrets.EC2_PUBLIC_IP }}:/home/ec2-user/
        scp -o StrictHostKeyChecking=no -i private_key.pem backend/common/config/.env ec2-user@${{ secrets.EC2_PUBLIC_IP }}:/home/ec2-user/common/config/.env

    - name: Deploy to EC2
      run: |
        # Install AWS CLI if not already installed
        if ! command -v aws &> /dev/null; then
          echo "AWS CLI not found. Installing..."
          sudo apt-get update
          sudo apt-get install -y awscli
        fi

        # SSH into the EC2 instance and run the Docker containers
        ssh -vvv-o StrictHostKeyChecking=no -i private_key.pem ec2-user@${{ secrets.EC2_PUBLIC_IP }} << 'EOF'
          # Install Docker if not already installed
          if ! command -v docker &> /dev/null; then
            echo "Docker not found. Installing..."
            sudo yum update -y
            sudo yum install docker -y
            sudo systemctl start docker
            sudo systemctl enable docker
            sudo usermod -a -G docker ec2-user
            echo "Docker installed successfully"
          fi

          # Install Docker Compose V2 if not present
          if ! command -v docker-compose &> /dev/null && ! docker compose version &> /dev/null; then
            echo "Installing Docker Compose V2..."
            # For Amazon Linux 2023
            sudo mkdir -p /usr/local/lib/docker/cli-plugins
            sudo curl -SL https://github.com/docker/compose/releases/latest/download/docker-compose-linux-x86_64 -o /usr/local/lib/docker/cli-plugins/docker-compose
            sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
          fi


          # Configure AWS CLI
          aws configure set region us-east-1

          # Verify IAM role
          aws sts get-caller-identity

          # Login to ECR without credentials (using IAM role)
          aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.us-east-1.amazonaws.com
          
          # Run docker compose with absolute path
          docker compose -f /home/ec2-user/docker-compose-ec2.yaml up -d
          docker exec ec2-user-ollama-1 ollama pull deepseek-r1:1.5b # For later
        EOF

